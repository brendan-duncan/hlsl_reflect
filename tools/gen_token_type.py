def enumName(s):
    if s == 'NULL': return 'Null'
    return s[0].upper() + s[1:]

fp = open('keywords.txt', 'rt')
keywords = [l.strip() for l in fp.readlines()]
fp.close()

fp = open('vector_matrix_types.txt', 'rt')
vectorMatrixTypes = [l.strip() for l in fp.readlines()]
fp.close()

fp = open('tokens.txt', 'rt')
tokens = [l.strip().split(' ') for l in fp.readlines()]
fp.close()

fp = open('types.txt', 'rt')
types = [l.strip() for l in fp.readlines()]
fp.close()

fp = open('../src/lib/hlsl/token_type.h', 'wt')

fp.write('''#pragma once
// Generated by tools/gen_token_type.py
#include <iostream>
#include <stdint.h>
#include <string>
#include <string_view>

namespace hlsl {

enum class TokenType : uint32_t {
  Undefined,
  EndOfFile,
  IntLiteral,
  FloatLiteral,
  Identifier,
''')

for k in tokens:
    fp.write('  {0},\n'.format(k[0]))

for k in keywords:
    fp.write('  {0},\n'.format(enumName(k)))

for k in vectorMatrixTypes:
    for i in range(1,5):
        fp.write('  {0}{1},\n'.format(enumName(k), i))
        for j in range(1,5):
            fp.write('  {0}{1}x{2},\n'.format(enumName(k), i, j))

fp.write('''};

inline std::ostream& operator<<(std::ostream& os, const TokenType& obj) {
  os << static_cast<std::underlying_type<TokenType>::type>(obj);
  return os;
}

const std::string& tokenTypeToString(TokenType t);

TokenType findTokenType(const std::string_view& s);

} // namespace hlsl
''')

fp.close()

fp = open('../src/lib/hlsl/token_type.cpp', 'wt')
fp.write('''// Generated by tools/gen_token_type.py
#include <array>
#include <map>
#include <set>
#include <string>
#include <string_view>
#include <variant>

#include "scanner/literal.h"
#include "scanner/template_types.h"
#include "token_type.h"

namespace hlsl {

// Used for diagnostics
static const std::map<TokenType, std::string> _tokenTypeToString{
  {TokenType::Undefined, "Undefined"},
  {TokenType::EndOfFile, "EndOfFile"},
  {TokenType::IntLiteral, "IntLiteral"},
  {TokenType::FloatLiteral, "FloatLiteral"},
  {TokenType::Identifier, "Identifier"},
''')

tokenCount = 0
for k in tokens:
    tokenCount += 1
    fp.write('  {{TokenType::{0}, "{0}"}},\n'.format(k[0]))

for k in keywords:
    tokenCount += 1
    fp.write('  {{TokenType::{0}, "{0}"}},\n'.format(enumName(k)))

for k in vectorMatrixTypes:
    for i in range(1,5):
        tokenCount += 1
        fp.write('  {{TokenType::{0}{1}, "{0}{1}"}},\n'.format(enumName(k), i))
        for j in range(1,5):
            tokenCount += 1
            fp.write('  {{TokenType::{0}{1}x{2}, "{0}{1}x{2}"}},\n'.format(enumName(k), i, j))
fp.write('}; // _tokenTypeToString\n\n')

fp.write('static const std::map<std::string_view, TokenType> tokenDefs {\n')
for k in tokens:
    fp.write('  {{"{0}", TokenType::{1}}},\n'.format(k[1], k[0]))

for k in keywords:
    fp.write('  {{"{0}", TokenType::{1}}},\n'.format(k, enumName(k)))

for k in vectorMatrixTypes:
    for i in range(1,5):
        tokenCount += 1
        fp.write('  {{"{0}{2}", TokenType::{1}{2}}},\n'.format(k, enumName(k), i))
        for j in range(1,5):
            tokenCount += 1
            fp.write('  {{"{0}{2}x{3}", TokenType::{1}{2}x{3}}},\n'.format(k, enumName(k), i, j))

fp.write('''}; // tokenDefs

const std::string& tokenTypeToString(TokenType t) {
  auto ti = _tokenTypeToString.find(t);
  if (ti == _tokenTypeToString.end()) {
    static const std::string undefined{"Undefined"};
    return undefined;
  }
  return (*ti).second;
}

TokenType findTokenType(const std::string_view& lexeme) {
  // This is a hot path we want to be as fast as possible. I tried using an
  // alternative "fast" map implementation but it was slower than std::map.
  // An optimization we can try is to use a "perfect hash" function like gperf.
  auto ti = tokenDefs.find(lexeme);
  if (ti != tokenDefs.end()) {
    return (*ti).second;
  }

  return matchLiteral(lexeme);
}

} // namespace hlsl
''')
fp.close()


fp = open('../src/lib/hlsl/ast/base_type.h', 'wt')
fp.write('''#pragma once
// Generated by tools/gen_token_type.py

#include "../token_type.h"

namespace hlsl {

enum class BaseType {
''')

for k in types:
  fp.write("  {0},\n".format(enumName(k)))

for k in vectorMatrixTypes:
    for i in range(1,5):
        fp.write('  {0}{1},\n'.format(enumName(k), i))
        for j in range(1,5):
            fp.write('  {0}{1}x{2},\n'.format(enumName(k), i, j))

fp.write('''};

BaseType tokenTypeToBaseType(TokenType t);

const std::string_view& baseTypeToString(BaseType t);

inline bool isSamplerBaseType(BaseType t) {
  return t == BaseType::Sampler ||
      t == BaseType::SamplerState ||
      t == BaseType::SamplerComparisonState;
}

} // namespace hlsl
''')
fp.close()


fp = open('../src/lib/hlsl/ast/base_type.cpp', 'wt')
fp.write('''// Generated by tools/gen_token_type.py
#include "base_type.h"

#include <map>

#include "../token_type.h"

namespace hlsl {

static const std::map<TokenType, BaseType> _tokenTypeToBaseType{
''')

for k in types:
  fp.write("  {{TokenType::{0}, BaseType::{0}}},\n".format(enumName(k)))

for k in vectorMatrixTypes:
    for i in range(1,5):
        fp.write('  {{TokenType::{0}{1}, BaseType::{0}{1}}},\n'.format(enumName(k), i))
        for j in range(1,5):
            fp.write('  {{TokenType::{0}{1}x{2}, BaseType::{0}{1}x{2}}},\n'.format(enumName(k), i, j))

fp.write('''};

static const std::map<BaseType, std::string_view> _baseTypeToString{
''')

for k in types:
  fp.write('''  {{BaseType::{0}, "{1}"}},\n'''.format(enumName(k), k))

for k in vectorMatrixTypes:
    for i in range(1,5):
        fp.write('''  {{BaseType::{0}{1}, "{2}{1}"}},\n'''.format(enumName(k), i, k))
        for j in range(1,5):
            fp.write('''  {{BaseType::{0}{1}x{2}, "{3}{1}x{2}"}},\n'''.format(enumName(k), i, j, k))

fp.write('''};

const std::string_view& baseTypeToString(BaseType t) {
  auto ti = _baseTypeToString.find(t);
  if (ti == _baseTypeToString.end()) {
    static const std::string_view undefined{"Undefined"};
    return undefined;
  }
  return (*ti).second;
}

BaseType tokenTypeToBaseType(TokenType t) {
  auto ti = _tokenTypeToBaseType.find(t);
  if (ti == _tokenTypeToBaseType.end()) {
    return BaseType::Undefined;
  }
  return (*ti).second;
}

} // namespace hlsl
''')
fp.close()
