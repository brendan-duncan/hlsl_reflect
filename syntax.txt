// Syntax rules for HLSL.
// HLSL does not have a formal specification so this is being derived from the documentation.
// I'm using the following notation
// (x)? means zero or one x
// (x)* means zero or more x
// (x)+ means one or more x
// (x,y,...)| means x, or y

Hlsl:
  (TopLevelStatement)+

TopLevelStatement:
  (Attributes)? Struct ;
  (Attributes)? CBuffer ;
  (Attributes)? TBuffer ;
  (Attributes)? Variable ;
  (Attributes)? Function ;
  (Attributes)? Typedef ;

Attributes:
  [ Attribute (, Attribute)? ] (Attributes)?

IdentifierList:
  IDENTIFIER (, IdentifierList)?

Attribute:
  IDENTIFIER
  IDENTIFIER ( Expression (, Expression)* )

BaseType:
  IDENTIFIER

StorageClass:
  IDENTIFIER

TypeModifier:
  IDENTIFIER

Type:
  (StorageClass)? (TypeModifier)? BaseType (< TYPE, INT_LITERAL (, INT_LITERAL)?) >)?

Typedef:
  Type IDENTIFIER

Variable:
  Type IDENTIFIER ([ ExpressionList ])? (= Expression)?

Variable:
  Type Name ([ ExpressionList ])? (: Semantic)? (: Packoffset)? (: Register)? (Annotations)? (= Expression)?

ExpressionList:
  Expression (, ExpressionList)?

Struct:
  STRUCT IDENTIFIER { (Field;)+ };

Field:
  Type MemberName;

CBuffer:
  CBUFFER IDENTIFIER { (Field;)+ }

TBuffer:
  TBUFFER IDENTIFIER { (Field;)+ }

Function:
  Type IDENTIFIER ( Parameters ) BlockStatement

BlockStatement:
  { (Statement;)* }

Statement:
  If ;
  Switch ;
  For ;
  DoWhile ;
  While ;
  BlockStatment ;
  Return ;
  BREAK ;
  CONTINUE ;
  DISCARD ;
  Variable ;
  Assignment ;
  Expression ;

If:
  IF ( Expression ) Statement

Switch:
  SWITCH ( Expression ) { (SwitchCase)+ }

SwitchCase:
  CASE Condition : (Statement)?
  DEFAULT : (Statement)?

For:
  FOR ( ExpressionList ; Expression ; ExpressionList ) Statement

DoWhile:
  DO { (Statement)* } WHILE ( Expression )

While:
  WHILE ( Expression ) Statement

Return:
  RETURN Expression

Assignment:
  IDENTIFIER ([ ExpressionList ])? = Expression

Expression:
  ShortCircuitOrExpression

ShortCircuitOrExpression:
  ShortCircuitAndExpression (|| ShortCircuitAndExpression)*

ShortCircuitAndExpression:
  InclusiveOrExpression (&& InclusiveOrExpression)*

InclusiveOrExpression:
  ExclusiveOrExpression (| ExclusiveOrExpression)*

ExclusiveOrExpression:
  AndExpression (^ AndExpression)*

AndExpression:
  EqualityExpression (& EqualityExpression)*

EqualityExpression:
  RelationalExpression ((==, !=)| RelationalExpression)*

RelationalExpression:
  ShiftExpression ((>, <, >=, <=)| ShiftExpression)*

ShiftExpression:
  AdditiveExpression ((>>, <<)| AdditiveExpression)*

AdditiveExpression:
  MultiplicativeExpression ((+, -)| MultiplicativeExpression)*

MultiplicativeExpression:
  UnaryExpression ((*, /, %) UnaryExpression)*

UnaryExpression:
  (-, !, ~, *, &)| UnaryExpression
  SingularExpression

SingularExpression:
  PrimaryExpression (PostfixExpression)?

PostfixExpression:
  [ ShortCircuitOrExpression ] (parsePostfixExpression)?
  . parsePostfixExpression

PrimaryExpression:
  IDENTIFIER ( ArgumentList )
  INT_LITERAL
  FLOAT_LITERAL
  ( Expression )
  BaseType ( Expression )

ArgumentList:
  Expression (, Expression)*
